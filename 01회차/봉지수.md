<!-- TOC start (generated with https://github.com/derlin/bitdowntoc) -->

- [01장 - 프로그래밍](#01-)
- [02장 - 자바스크립트란?](#02-)
- [03장 - 자바스크립트 개발 환경과 실행 방법](#03-)
- [04장 - 변수](#04-)
   * [SUMMARY](#summary)
   * [QUIZ](#quiz)
- [05장 - 표현식과 문](#05-)
   * [SUMMARY](#summary-1)
   * [QUIZ](#quiz-1)
- [06장 - 데이터 타입](#06-)
   * [SUMMARY](#summary-2)
   * [QUIZ](#quiz-2)
- [07장 - 연산자](#07-)
   * [SUMMARY](#summary-3)
   * [QUIZ](#quiz-3)
- [08장 - 제어문](#08-)
   * [SUMMARY](#summary-4)
   * [QUIZ](#quiz-4)
- [09장 - 타입 변환과 단축 평가](#09-)
   * [SUMMARY](#summary-5)
   * [QUIZ](#quiz-5)

<!-- TOC end -->


<!-- TOC --><a name="01-"></a>
# 01장 - 프로그래밍

- 프로그래밍의 목적은 문제 해결이다.
    - 문제 —(문제 해결 능력)—> 해결 방안 —(문법/의미)—> 코드
- 컴파일러는 개발자의 언어와 컴퓨터의 언어를 모두 이해하는 번역가다.
    - 기계어로 직접 명령을 전달하는 것을 대신할 가장 유용한 대안은 사람이 이해할 수 있는 약속된 구문(문법)으로 구성된 “프로그래밍 언어”를 사용해 프로그램을 작성한 후, 그것을 컴퓨터가 이해할 수 있는 기계어로 변환하는 일종의 번역기를 이용하는 것이다.
    - 이 일종의 번역기를 **컴파일러** 혹은 **인터프리터**라고 한다.

<!-- TOC --><a name="02-"></a>
# 02장 - 자바스크립트란?

- 브라우저에 따라 웹페이지가 정상적으로 동작하지 않는 **크로스 브라우징 이슈** → ECMA 인터내셔널에 자바스크립트 표준화 요청 → ECMAScript
- Ajax (Asynchronous JavaScript and XML)
    - 자바스크립트를 이용해 서버와 브라우저가 **비동기** 방식으로 데이터를 교환할 수 있는 통신 기능이다.
    - 이전에는 HTML 코드를 서버로부터 전송받아 웹페이지 전체를 렌더링했다. → 페이지 깜빡임 현상
    - Ajax의 등장으로 인해, 서버로부터 필요한 데이터만 전송받아 변경해야 하는 부분만 한정적으로 렌더링하는 방식이 가능해졌다.
- jQuery
    - DOM (Document Object Model)을 더욱 쉽게 제어할 수 있게 되었다.
    - 크로스 브라우징 이슈도 어느 정도 해결되었다.
- V8 자바스크립트 엔진
    - 자바스크립트로 웹 애플리케이션을 구축하려는 시도가 늘면서 더욱 빠르게 동작하는 자바스크립트 엔진이 필요했다.
    - V8 자바스크립트 엔진의 등장으로 자바스크립트가 더욱 발전했으며, 과거 웹 서버에서 수행되던 로직들이 대거 클라이언트(브라우저)로 이동함에 따라 프런트엔드 영역이 주목받는 계기가 되었다.
- Node.js
    - V8 자바스크립트 엔진으로 빌드된 자바스크립트 런타임 환경이다.
    - 이전에 브라우저의 자바스크립트 엔진에서만 동작하던 자바스크립트를, 브라우저 이외의 환경에서도 동작할 수 있도록 자바스크립트 엔진을 브라우저에서 독립시킨 자바스크립트 실행 환경이다.
    - Node.js의 등장으로 자바스크립트는 브라우저를 벗어나 서버 사이드 애플리케이션 개발에서도 사용할 수 있는 범용 프로그래밍 언어가 되었다.
- SPA (Single Page Application) 프레임워크
    - 개발 규모와 복잡도 상승으로 인해 확장성을 위한 프레임워크가 등장하게 되었다.
- 각 브라우저 제조사는 ECMAScript 사양을 준수해서 브라우저에 내장되는 자바스크립트 엔진을 구현한다.
- 자바스크립트는 일반적으로 ECMAScript를 아우르는 개념이다.
    - ECMAScript + 브라우저가 별도 지원하는 클라이언트 사이드 Web API 등
    - 클라이언트 사이드 Web API는 월드 와이드 웹 콘소시엄(W3C)에서 별도의 사양으로 관리한다.
- 자바스크립트는 개발자가 별도의 컴파일 작업을 수행하지 않는 **인터프리터 언어**다.
    - 코드가 실행되는 단계인 런타임에 한 줄씩 바이트코드로 변환하고 즉시 실행한다.
    - 실행 파일을 생성하지 않는다.
    - 코드가 실행될 때마다 인터프리트 과정이 반복 수행되므로, 코드 실행 속도가 비교적 느리다.
- 자바스크립트는 **명령형, 함수형, 프로토타입 기반 객체지향 프로그래밍**을 지원하는 멀티 패러다임 프로그래밍 언어다.
- 인터넷 익스플로러나 구형 브라우저는 ES6를 대부분 지원하지 않는다.
    - 바벨과 같은 트랜스파일러를 사용해 ES5 이하의 사양으로 다운그레이드를 고려해볼 수 있다.

<!-- TOC --><a name="03-"></a>
# 03장 - 자바스크립트 개발 환경과 실행 방법

- 브라우저는 파싱된 HTML 요소를 선택하거나 조작하는 기능의 집합인 DOM API를 기본적으로 제공한다. 하지만 브라우저 외부에서 자바스크립트 개발 환경을 제공하는 것이 주 목적인 Node.js는 DOM API를 제공하지 않는다.
- 브라우저 환경의 자바스크립트는 파일 시스템을 제공하지 않는다. 보안상의 이유로.
- 브라우저는 ECMAScript + **클라이언트 사이드 Web API**를 지원한다.
    - DOM, BOM, Canvas, XMLHttpRequest, fetch, requestAnimationFrame, SVG, Web Storage, Web Component, Web Worker
- Node.js는 ECMAScript + Node.js 고유의 API를 지원한다.
- 브라우저의 콘솔 또는 Node.js의 REPL에서 자바스크립트 코드를 실행할 수 있지만 애플리케이션을 개발하는 단계에서 사용하기에는 부족함이 많다.
- 코드 에디터를 사용하면 코드 자동 완성, 문법 오류 감지, 디버깅, Git 연동 등 강력하고 편리한 기능을 활용할 수 있다.
    - VS Code

<!-- TOC --><a name="04-"></a>
# 04장 - 변수

- 애플리케이션은 데이터를 다룬다. 아무리 복잡한 애플리케이션이라 해도 데이터를 입력받아 처리하고 그 결과를 출력하는 것이 전부다.
- 변수는 프로그래밍 언어에서 데이터를 관리하기 위한 핵심 개념이다.
- 컴퓨터는 CPU를 사용해 연산하고, 메모리를 사용해 데이터를 기억한다.
    - 메모리는 데이터를 저장할 수 있는 메모리 셀의 집합체다.
    - 메모리 셀 하나의 크기는 1byte = 8bit다.
    - 컴퓨터는 메모리 셀의 크기, 즉 1byte 단위로 데이터를 저장하거나 읽어들인다.
    - 각 셀은 고유의 메모리 주소를 갖는다. 메모리 주소는 메모리 공간의 위치를 나타낸다.
    - 4GB = 2^32byte 메모리는 0부터 2^32까지의 메모리 주소를 갖는다.
        - 0 ~ 4,294,967,295
        - 0x00000000 ~ 0xFFFFFFFF
- 메모리에 저장되는 모든 값은 2진수로 저장된다.
- **변수는 하나의 값을 저장하기 위해 확보한 메모리 공간 자체 또는 그 메모리 공간을 식별하기 위해 붙인 이름을 말한다.**

```jsx
var result = 10 + 20;
```

<img width=500 alt="" src="https://github.com/user-attachments/assets/1402ea0c-d496-4aa5-99fb-595b60ee43a8" />


- 상징적 이름인 변수는 프로그래밍 언어의 컴파일러 또는 인터프리터에 의해 값이 저장된 메모리 공간의 주소로 치환되어 실행된다.
    - 따라서 개발자가 직접 메모리 주소를 통해 값을 저장하고 참조할 필요가 없고 변수를 통해 안전하게 값에 접근할 수 있다.
    - 변수 이름을 사용해 참조를 요청하면 자바스크립트 엔진은 변수 이름과 매핑된 메모리 주소를 통해 메모리 공간에 접근해서 저장된 값을 반환한다.
- 변수 선언이란 변수를 생성하는 것을 말한다.
    - 값을 저장하기 위한 메모리 공간을 확보하고 변수 이름과 확보된 메모리 공간의 주소를 연결해서 값을 저장할 수 있게 준비하는 것이다.
- **변수를 사용하려면 반드시 선언이 필요하다. 변수를 선언할 때는 var, let, const 키워드를 사용한다.**

```jsx
var score;
```

- var 키워드를 만나면 자바스크립트 엔진은 뒤에 오는 변수 이름으로 새로운 변수를 선언한다.
- 초기화 단계: 값을 저장하기 위한 메모리 공간을 확보하고 암묵적으로 undefined를 할당해 초기화한다.
    - 만약 초기화 단계를 거치지 않으면, 확보된 메모리 공간에는 이전에 다른 애플리케이션이 사용했던 쓰레기 값이 남아 있을 수 있다.
- 변수 이름을 비롯한 모든 식별자는 실행 컨텍스트에 등록된다.
    - 실행 컨텍스트는 자바스크립트 엔진이 소스코드를 평가하고 실행하기 위해 필요한 환경을 제공하고 코드의 실행 결과를 실제로 관리하는 영역이다.
    - 자바스크립트 엔진은 실행 컨텍스트를 통해 식별자와 스코프를 관리한다.
- ReferenceError(참조 에러)는 식별자를 통해 값을 참조하려 했지만 자바스크립트 엔진이 등록된 식별자를 찾을 수 없을 때 발생하는 에러다.
- **변수 선언은 런타임이 아니라 그 이전 단계에서 먼저 실행된다.**
    - 런타임: 소스코드가 한 줄씩 순차적으로 실행되는 시점

```jsx
console.log(score); // undefined

var score; // 변수 선언문
```

- 자바스크립트 엔진은 변수 선언을 포함한 모든 선언문(변수 선언문, 함수 선언문 등)을 소스코드에서 찾아내 먼저 실행한다. 그리고 소스코드의 평가 과정이 끝나면 비로소 변수 선언을 포함한 모든 선언문을 제외하고 소스코드를 한 줄씩 순차적으로 실행한다.
- **변수 선언문이 코드의 선두로 끌어 올려진 것처럼 동작하는 자바스크립트 고유의 특징을 변수 호이스팅**이라 한다.
- **변수 선언은 런타임 이전에 먼저 실행되지만, 값의 할당은 런타임에 실행된다.**

```jsx
console.log(score); // undefined

var score = 80; // 변수 선언과 값의 할당

console.log(score); // 80
```

- 변수에 값을 할당할 때는 이전 값 undefined가 저장되어 있던 메모리 공간을 지우고 그 메모리 공간에 할당 값 80을 새롭게 저장하는 것이 아니라, 새로운 메모리 공간을 확보하고 그곳에 할당 값 80을 저장한다.
    - 왜 덮어쓰지 않는 걸까?

<img width=500 alt="" src="https://github.com/user-attachments/assets/d1e0c1b9-9f29-4f42-b662-9065913081e9" />


- **값을 재할당할 수 없어서 변수에 저장된 값을 변경할 수 없다면 변수가 아니라 상수라 한다.**
- 가비지 콜렉터는 애플리케이션이 할당한 메모리 공간을 주기적으로 검사하여 더 이상 사용되지 않는 메모리를 해제하는 기능을 말한다.
    - 어떤 식별자도 참조하지 않는 메모리 공간을 해제한다.
    - 자바스크립트는 가비지 콜렉터를 내장하고 있는 매니지드 언어로서 메모리 누수를 방지한다.
        - C 언어 같은 언매니지드 언어는 개발자가 명시적으로 메모리를 할당하고 해제하기 위해 malloc()과 free() 같은 저수준 메모리 제어 기능을 제공한다.
- 식별자는 특수문자를 제외한 문자, 언어스코어(_), 달러 기호($)로 시작해야 한다.
    - 숫자로 시작하는 것은 허용하지 않는다.
    - 예약어는 식별자로 사용할 수 없다.
    - 자바스크립트는 대소문자를 구별한다.
- 자바스크립트에서는 일반적으로 변수나 함수의 이름에는 camelCase를 사용하고, 생성자 함수, 클래스의 이름에는 PascalCase를 사용한다.

<!-- TOC --><a name="summary"></a>
## SUMMARY
- 컴퓨터는 1바이트(메모리 셀의 크기) 단위로 데이터를 저장하거나 읽어들인다.
- 변수는 식별자다. 메모리 공간을 식별하기 위해 붙인 이름이다. -> 변수 이름으로 메모리 공간을 참조하여 값 재사용 가능
- `var result = 10 + 20;` -> 생성된 값 30은 새로운 메모리 공간에 저장된다. 이전 값만 교체되는 게 아님!

<!-- TOC --><a name="quiz"></a>
## QUIZ
- 자바스크립트가 var 키워드를 사용한 변수 선언에서 암묵적으로 undefined로 초기화하는 이유가 뭘까?
  <details>
    <summary></summary>
    <div markdown="1">
      쓰레기 값이 참조되는 것을 방지하기 위해서 그렇기도 하다.
    </div>
  </details>
- 변수 호이스팅이란 뭘까?
  <details>
    <summary></summary>
    <div markdown="1">
      변수 선언문이 코드 젤 위로 끌어올려진 것처럼 동작하는 특성이다.<br/>
      사실은 런타임 이전에 소스코드의 평가과정에서, 선언문이 먼저 실행돼서 메모리공간이 할당되어 초기화된 것이다.
    </div>
  </details>

<!-- TOC --><a name="05-"></a>
# 05장 - 표현식과 문
<!-- TOC --><a name="summary-1"></a>
## SUMMARY
- 값은 표현식이 평가되어 생성된 결과를 말한다.
- 보통 리터럴로 값을 생성한다. 리터럴은 값 생성을 위한 약속된 표기법이다.
- 문에는 표현식인 문과 표현식이 아닌 문이 있다. 표현식인 문은 평가되어 값을 생성한다.
  - `3` (숫자 리터럴) -> 평가되어 숫자 값 3 생성 -> 표현식이다.
  - `10 + 20;` (숫자 리터럴, 연산자, 숫자 리터럴) -> 평가되어 숫자 값 30 생성 -> 표현식이다.

<!-- TOC --><a name="quiz-1"></a>
## QUIZ
- 변수 선언문은 표현식일까? `var x;`
  <details>
    <summary></summary>
    <div markdown="1">
      NO. 선언문은 평가되어 값을 생성하지 않는다. 그냥 선언할 뿐.<br/>
      표현식인 문과 표현식이 아닌 문을 구별하는 간단한 방법은 변수에 할당해 보는 것이다.
    </div>
  </details>
- 할당문은 표현식일까? `x = 100;`
  <details>
    <summary></summary>
    <div markdown="1">
      YES. var foo = x = 100;<br/>
      foo 변수에 할당되는 값은?<br/>
      할당문은 할당된 값으로 평가된다.
    </div>
  </details>

<!-- TOC --><a name="06-"></a>
# 06장 - 데이터 타입
<!-- TOC --><a name="summary-2"></a>
## SUMMARY
- 데이터 타입은 원시 타입(primitive type)과 객체 타입(object/reference type)으로 나뉜다.
- 원시 타입의 값은 변경 불가능한 값(immutable value)이다.
- 변수의 데이터 타입에 따라 그 크기만큼 메모리 공간을 확보하고 이진수로 저장한다. 값을 읽어올 때는 데이터 타입에 따라 그 크기만큼 읽어들이고 해석한다.

<!-- TOC --><a name="quiz-2"></a>
## QUIZ
- `undefined`와 `null`의 차이는?
  <details>
    <summary></summary>
    <div markdown="1">
      undefined는 자바스크립트 엔진이 변수를 초기화할 때 사용하는 값인 반면,<br/>
      null은 개발자가 의도적으로 변수에 값이 없다는 것을 명시할 때 사용하는 값이다.
    </div>
  </details>
- 원시 타입의 값은 왜 변경 불가능한 걸까?
  <details>
    <summary></summary>
    <div markdown="1">
      값의 신뢰도를 높이기 위한 목적도 있다.
    </div>
  </details>

<!-- TOC --><a name="07-"></a>
# 07장 - 연산자
<!-- TOC --><a name="summary-3"></a>
## SUMMARY
- 연산자는 하나 이상의 표현식을 대상으로 산술, 할당, 비교, 논리, 타입, 지수 연산 등을 수행해 하나의 값을 만든다.
- `+ 연산자`는 피연산자 중 하나 이상이 문자열인 경우 문자열 연결 연산자로 동작한다.
- 부수 효과가 있는(할당이 이루어지는) 연산자는 할당 연산자(=), 증가/감소 연산자(++/--), delete 연산자다.

<!-- TOC --><a name="quiz-3"></a>
## QUIZ
- 동등 비교(==) 연산자와 일치 비교(===) 연산자의 차이는?
  <details>
    <summary></summary>
    <div markdown="1">
      일치 비교(===) 연산자는 타입까지 비교한다.<br/>
      '0' == 0 -> 암묵적 타입 변환O -> 타입을 일치시킨 후에 같은 값인지 비교한다.<br/>
      '0' === 0 -> 암묵적 타입 변환X -> 타입까지 엄격히 비교한다.
    </div>
  </details>

<!-- TOC --><a name="08-"></a>
# 08장 - 제어문
<!-- TOC --><a name="summary-4"></a>
## SUMMARY
- 제어문을 사용하면 코드의 실행 흐름을 인위적으로 제어할 수 있다. -> 조건문, 반복문
- switch 문에서 break 문이 없다면 case 문의 표현식과 일치하지 않더라도 실행 흐름이 다음 case 문으로 연이어 이동한다. -> 폴스루(fall through)
- for 문은 반복 횟수가 명확할 때 주로 사용하고, while 문은 반복 횟수가 불명확할 때 주로 사용한다.

<!-- TOC --><a name="quiz-4"></a>
## QUIZ
- if ... else 문, switch 문, continue 문 등의 사용 판단 기준은?
  <details>
    <summary></summary>
    <div markdown="1">
      가독성
    </div>
  </details>

<!-- TOC --><a name="09-"></a>
# 09장 - 타입 변환과 단축 평가
<!-- TOC --><a name="summary-5"></a>
## SUMMARY
- 개발자가 의도적으로 값의 타입을 변환하는 것을 `명시적 타입 변환`, 자바스크립트 엔진에 의해 암묵적으로 타입이 자동 변환되는 것을 `암묵적 타입 변환`이라 한다.
- `단축 평가`는 표현식을 평가하는 도중에 평가결과가 확정된 경우 나머지 평가 과정을 생략하는 것을 말한다.

<!-- TOC --><a name="quiz-5"></a>
## QUIZ
- 표현식 `false || 'Dog'`의 평가 결과는?
  <details>
    <summary></summary>
    <div markdown="1">
      "Dog"
    </div>
  </details>

