# 04. 변수

## 1) 변수의 존재 목적
- 간단하게는 데이터의 관리
- 사람처럼 동작하는 자바스크립트의 엔진이 데이터 처리를 위해 데이터를 저장해둔 값의 주소를 변수로 저장하여 관리하기 위함
- 즉, 하나의 값을 저장하기 위해 확보한 메모리 공간 자체 또는 메모리 공간 식별을 위해 붙인 이름

## 2) ‘할당’
- 변수에 값을 저장하는 행위
- 할당 연산자 ‘=’ 사용
- 재할당도 가능(상수는 불가능)

## 3) ‘참조’
- 변수에 저장된 값을 불러옴

## 4) ‘식별자’
- 변수 이름(어떤 값을 구별해서 식별할 수 있는 고유한 이름)
- 식별자는 데이터의 값이 아닌 데이터가 저장되어 있는 메모리의 주소를 기억함

## 5) ‘선언’
- 변수를 생성하는 것
- 변수를 사용하기 위해 반드시 필요한 과정
- `var`, `let`, `const` 키워드를 사용하여 선언
- 선언의 단계: 선언 → 초기화
- 선언 시 값 할당도 동시에 가능하나, 값 할당하지 않을 경우 `undefined`로 할당됨(선언은 런타임 이전에, 할당은 런타임 시 실행)

## 6) ‘변수 호이스팅’
- 변수 선언문은 소스코드가 차례로 진행되는 런타임 순서에 따라 실행되는 것이 아니라, 선두로 진행되며 이를 호이스팅이라 함

## 7) ‘매니지드 언어’
- 자바스크립트는 C 언어와 달리 메모리 제어가 불가능한데, 메모리 제어가 가능한 언어를 언매니지드 언어, 불가능한 언어를 매니지드 언어라 칭함
- 언매니지드 언어는 성능 확보가 가능하지만 치명적 오류 생산의 가능성이 존재하며, 매니지드 언어는 성능 확보는 어렵지만 일정한 생산성의 확보가 가능함

## 8) 식별자 네이밍 규칙
- 특수문자 불가, 예약어 불가
- 문자, 숫자, 언더스코어(`_`), 달러 기호(`$`)는 가능
- 시작 문자로 숫자는 불가능
- 존재 목적을 알기 쉽게 표현하는 것이 좋음


# 05. 표현식과 문

## 1) ‘값’
- 식이 평가되어 생성된 결과
- 변수에 할당됨

## 2) ‘평가’
- 식을 해석하여 값을 생성하거나 참조

## 3) ‘리터럴’
- 사람이 이해할 수 있는 문자나 약속된 기호를 사용해 값을 생성하는 표기법
- 예: 정수 리터럴, 문자열 리터럴(`’문자’`), 불리언 리터럴(`true`, `false`) 등

## 4) ‘표현식’
- 값으로 평가될 수 있는 문
- 예: 리터럴, 식별자(변수, 함수 등의 이름), 연산자, 함수 호출 등
- 표현식은 값으로 평가되므로 값처럼 사용 가능(값의 자리에 표현식 사용 가능)

## 5) ‘문’
- 프로그램을 구성하는 기본 단위이자 최소 실행 단위
- 문의 집합 = 프로그램
- 여러 개의 토큰(문법적인 의미를 가진 더 이상 나눌 수 없는 코드의 기본 요소, 예: 키워드, 식별자, 연산자, 리터럴, 세미콜론 등)으로 구성
- 컴퓨터에 내리는 명령으로 명령문이라고도 함
- 선언문, 할당문, 조건문, 반복문 등으로 구분

## 6) 세미콜론에 대해
- 세미콜론은 문의 종료를 나타냄
- 단, `if`문, `for`문, 함수 등의 코드 블록은 자체 종결성이 있으므로 세미콜론 붙이지 않음
- 자바스크립트 엔진은 세미콜론 자동 삽입 기능을 가지고 있기 때문에 세미콜론 생략 가능
- 다만 세미콜론 자동 삽입 기능의 작동을 제대로 예측하지 못할 수 있으므로 붙이는 것 권장

## 7) 표현식인 문과 표현식이 아닌 문의 구분
- 표현식인 문(값으로 평가 가능): 예 - 할당문
- 표현식이 아닌 문(값으로 평가 불가): 예 - 변수 선언문
- 구분하는 가장 간단한 방법은 변수에 할당해 보는 것


# 06. 데이터 타입

## 1) 데이터 타입의 정의
- 값의 종류를 뜻함
- ES6는 7개 데이터 타입 제공
- 원시 타입과 객체 타입으로 분류

### 1. 원시 타입
- 숫자, 문자열, 불리언, `undefined`, `null`, 심벌(`symbol`) 타입

#### * 숫자 타입
- 자바스크립트에서는 숫자 타입의 모든 수를 실수로 처리(정수, 실수의 구분X)
- 특별한 값: `Infinity`(양의 무한대), `-Infinity`(음의 무한대), `NaN`(not-a-number, 산술 연산 불가, 대소문자 구분 필요)

#### * 문자열 타입
- 텍스트 데이터를 나타냄
- 작은 따옴표, 큰 따옴표, 또는 백틱(``` ` ```)으로 사용
- 템플릿 리터럴 - ES6부터 도입, 백틱 사용, 줄바꿈과 공백을 그대로 허용, 문자열 조합 시 `${}`을 통해 표현식 삽입하여 간단하게 가능

#### * 불리언 타입
- `true`, `false`

#### * undefined 타입
- `undefined` 값이 유일
- 자바스크립트 엔진이 변수를 초기화할 때 사용하는 값(개발자의 의도X)
- `undefined`를 통해 초기화되지 않은 변수임을 확인 가능

#### * null 타입
- `null` 값이 유일
- 대소문자 구분 필요
- 변수에 값이 없음을 나타낼 때 사용(가비지 콜렉션 이용 목적으로 사용하기도 함)
- 함수가 유효한 값을 반환할 수 없을 때 반환하는 값이기도 함

#### * 심벌(symbol) 타입
- 다른 값과 중복되지 않는 유일무이한 값
- 이름 충돌의 위험이 없는 객체의 유일한 프로퍼티 키를 만들기 위해 사용
- `Symbol` 함수를 호출하여 생성

### 2. 객체 타입
- 객체, 함수, 배열 등

## 2) 데이터 타입의 필요성
- 자바스크립트 엔진이 값의 종류에 따라 메모리를 확보하고 읽어들이므로 값의 종류인 데이터 타입 명시가 필요

### 동적 타이핑
- 자바스크립트는 정적 타입 언어인 C 언어, 자바 등과 달리 데이터 타입에 관계없이 자유롭게 변수에 값 할당이 가능
- 즉, 자바스크립트의 변수는 선언이 아닌 할당에 의해 데이터 타입이 결정됨
- 단, 변수 값이 언제든지 변할 수 있으므로 변수 값 추적이 어려우며, 값 확인 전에는 타입을 확신하는 것도 어렵고, 자바스크립트 엔진에 의해 암묵적으로 타입이 변경되기도 함 → 자바스크립트는 유연성은 높지만 신뢰성이 떨어지게 됨

### 변수 사용 시 주의점
- 변수는 꼭 필요한 경우에 한해서만 사용
- 변수의 스코프(유효 범위)는 최대한 좁게 만들기
- 전역 변수는 최대한 사용 자제
- 변수보다는 상수 사용하여 값 변경 억제
- 변수 이름은 변수의 목적이나 의미 파악 쉽게 네이밍하기

---

# 07. 연산자

---

연산자는 하나 이상의 표현식을 대상으로 산술, 할당, 비교, 논리, 타입, 지수 연산 등을 수행해 하나의 값을 만든다.

- 연산의 대상을 **피연산자**라고 한다.
- 피연산자는 값으로 평가될 수 있는 표현식이어야 한다.
- 표현식은 값으로 평가될 수 있는 문이다.
javascript
5 + 5 // 10
color = 'red'
'hello' + 'world'
---

## 1) 이항 산술 연산자

두 개의 피연산자를 산술하여 숫자값을 만든다.

- `+`, `-`, `*`, `/`, `%`

---

## 2) 단항 산술 연산자

한 개의 피연산자를 산술하여 숫자 값을 만든다.

- `++`, `--`, `+`, `-`

증감, 감소는 위치에 따라 의미가 달라진다.
javascript
let result = 5; // 5
result = x++; // 선할당 후증가 5, 6
result = ++x; // 선증가 후할당 7
result = x--; // 선할당 후감소 7, 6
result = --x; // 선감소 후할당 5
---

## 3) 문자열 연결 연산자

`+` 연산자는 피연산자 중 하나 이상이 문자열일 경우, 문자열 연결 연산자로 동작한다.
javascript
'1' + 1 // '11'
'1' + true // '1true'
'1' + false // '1false'
자바스크립트 엔진에서는 개발자의 의도와 상관없이 **암묵적 타입 변환**이 일어난다.

---

## 4) 할당 연산자

우항에 있는 피연산자의 평가 결과를 좌항에 있는 변수에 할당한다.

- `=`, `+=`, `-=`, `/=`, `%=`

---

## 5) 동등, 일치 비교 연산자

자바스크립트 엔진에서는 개발자의 의도와 상관없이 암묵적으로 타입 변환이 일어난다.

- **동등 비교 연산자**는 좌항과 우항의 피연산자를 비교할 때 먼저 암묵적 타입 변환을 통해 타입을 일치시킨 후 값을 비교한다.
- **일치 비교 연산자**는 타입과 값을 모두 비교하여 동일할 때 `true`를 반환한다.

동등 비교 연산자는 예측하기 어려운 결과를 만들 수 있기 때문에 일치 비교 연산자 사용을 권장한다.

---

## 6) 삼항 조건 연산자

조건식의 평가 결과에 따라 반환할 값을 결정한다.
javascript
let a = 2;
let result = a % 2 === 0 ? '짝수' : '홀수';
console.log(result); // '짝수'
---

## 7) 논리 연산자

좌항과 우항의 피연산자를 논리적으로 비교한다.

- `&&` (AND), `||` (OR), `!` (NOT)

---

# 08. 제어문

---

제어문은 조건에 따라 코드 블록을 실행하거나 반복 실행 시 사용된다.

---

## 1) if...else 문

주어진 조건식의 평가 결과에 따라 실행할 코드 블럭을 결정한다.
javascript
let x = 10;

if (x > 5) {
  console.log('x는 5보다 큽니다.');
} else {
  console.log('x는 5보다 작거나 같습니다.');
}
---

## 2) else if 문

`if` 문과 `else` 문은 각각 한 번씩만 사용할 수 있지만, `else if` 문은 여러 번 사용할 수 있다.

---

## 3) switch 문

주어진 표현식을 평가하여 그 값과 일치하는 `case` 문으로 실행 흐름을 옮긴다.
javascript
let day = 3;
let dayName;

switch (day) {
  case 1:
    dayName = '월요일';
    break;
  case 2:
    dayName = '화요일';
    break;
  case 3:
    dayName = '수요일';
    break;
  default:
    dayName = '알 수 없음';
}

console.log(dayName); // '수요일'
---

## 4) for 문

조건식이 거짓으로 평가될 때까지 코드 블록을 반복 실행한다.
javascript
for (let i = 0; i < 5; i++) {
  console.log(i); // 0, 1, 2, 3, 4
}
---

### 무한 루프

종료 조건이 없거나 항상 참인 조건식을 사용하는 반복문은 무한 루프가 된다.
javascript
while (true) {
  console.log('이 코드는 무한히 실행됩니다.');
}
---

### 이중 for 문
javascript
for (let i = 0; i < 3; i++) {
  for (let j = 0; j < 3; j++) {
    console.log(i: ${i}, j: ${j});
  }
}
---

## 5) while 문

주어진 조건식의 결과가 참이면 코드 블록을 계속해서 반복 실행한다.
javascript
let count = 0;

while (count < 5) {
  console.log(count);
  count++;
}
---

## 6) break 문

레이블 문, 반복문 또는 `switch` 문의 코드 블록을 탈출한다.
javascript
for (let i = 0; i < 10; i++) {
  if (i === 5) break;
  console.log(i); // 0, 1, 2, 3, 4
}
---

## 7) continue 문

반복문의 코드 블록 실행을 현 지점에서 중단하고, 반복문의 증감식으로 실행 흐름을 이동시킨다.
javascript
for (let i = 0; i < 5; i++) {
  if (i === 2) continue;
  console.log(i); // 0, 1, 3, 4
}
---

# 09. 타입 변환

---

개발자의 의도에 따라 다른 타입으로 변환하는 것을 **명시적 타입 변환**, 개발자의 의도와는 상관없이 다른 타입으로 변환하는 것을 **암묵적 타입 변환**이라 한다.

- 명시적 타입 변환, 암묵적 타입 변환은 기존 원시 값을 직접 변경하지 않는다.
- 원시 값은 변경 불가능한 값이므로 변경할 수 없다.
- 타입 변환이란 기존 원시 값을 사용해 다른 타입의 새로운 원시 값을 생성하는 것이다.

---

## 1) 암묵적 타입 변환

자바스크립트 엔진이 개발자의 의도와 관계없이 타입을 변환하는 것.
javascript
1 + '1'; // '11'
2 * '3'; // 6
true + false; // 1
---

## 2) 명시적 타입 변환

개발자가 명시적으로 타입을 변환하는 것.

### 문자열 타입으로 변환
javascript

// 1. String 생성자 함수를 new 연산자 없이 호출
String(1); // '1'
String(true); // 'true'
String(NaN); // 'NaN'

// 2. Object.prototype.toString 메서드를 사용
(1).toString(); // '1'
(NaN).toString(); // 'NaN'
(true).toString(); // 'true'

// 암묵적 타입 변환 활용: 문자열 연결 연산자
1 + ''; // '1'
true + ''; // 'true'

### 숫자 타입으로 변환
javascript
// 1. Number 생성자 함수 사용
Number('0'); // 0
Number(true); // 1
Number(false); // 0

// 2. parseInt, parseFloat 함수 사용
parseInt('0'); // 0
parseFloat('10.53'); // 10.53

// 암묵적 타입 변환 활용: +단항 산술 연산자 사용
+'0'; // 0
+true; // 1
+false; // 0

// 암묵적 타입 변환 활용: *산술 연산자 사용
'0' * 1; // 0
true * 1; // 1
false * 1; // 0

### 불리언 타입으로 변환
javascript
// 1. Boolean 생성자 함수 사용
Boolean('x'); // true
Boolean(''); // false
Boolean('false'); // true
Boolean(0); // false
Boolean(1); // true
Boolean({}); // true
Boolean([]); // true

// 2. ! 부정 논리 연산자를 두 번 사용하는 방법
!!'x'; // true
!!''; // false
!!'false'; // true
!!0; // false
!!1; // true
!!{}; // true
!![]; // true
---