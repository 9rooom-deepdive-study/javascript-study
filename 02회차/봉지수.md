# 10장 - 객체 리터럴
## SUMMARY
- 원시 값은 변경 불가능한 값이지만, 객체는 변경 가능한 값이다.
- 객체는 프로퍼티와 메서드로 구성된 집합체다.
- 객체는 프로퍼티의 집합이며, 프로퍼티는 키와 값으로 구성된다.

# 11장 - 원시 값과 객체의 비교
## SUMMARY
- 변경 불가능하다는 것은 변수가 아니라 값에 대한 진술이다.
- 원시 값은 어떤 일이 있어도 불변한다. 이러한 원시 값의 특성은 데이터 신뢰성을 보장한다.
  - `str[0] = 'S'`처럼 이미 생성된 문자열의 일부 문자를 변경해도 반영되지 않는다.
- 객체를 할당한 변수가 기억하는 메모리 주소를 통해 메모리 공간에 접근하면 참조 값에 접근할 수 있다. 참조 값은 생성된 객체가 저장된 메모리 공간의 주소, 그 자체다.
<img width="700" src="https://github.com/user-attachments/assets/38d0440c-c5ff-43a2-896b-f4e2658f0f81">

# 12장 - 함수
## SUMMARY
- 함수는 일련의 과정을 문으로 구현하고 코드 블록으로 감싸서 하나의 실행 단위로 정의한 것이다.
- 함수는 몇 번이든 호출할 수 있으므로 코드의 재사용이라는 측면에서 매우 유용하다.
- 함수 선언문은 표현식이 아닌 문이다. 함수 선언문은 함수 리터럴 표현식으로 해석되지 않는다.
- 함수는 함수 이름으로 호출하는 것이 아니라, 함수 객체를 가리키는 식별자로 호출한다.
  - 자바스크립트 엔진이 암묵적으로 생성한 식별자로 호출한다.

# 13장 - 스코프
## SUMMARY
- 모든 식별자는 자신이 선언된 위치에 의해 다른 코드가 식별자 자신을 참조할 수 있는 유효 범위가 결정된다. 이를 스코프라 한다. 즉, 스코프는 식별자가 유효한 범위를 말한다.
- 변수를 참조할 때 자바스크립트 엔진은 스코프 체인을 통해, 변수를 참조하는 코드의 스코프에서 시작하여 상위 스코프 방향으로 이동하며 선언된 변수를 검색한다.
  - 스코프 체인은 물리적인 실체로 존재한다. 변수 선언이 실행되면 변수 식별자가 이 자료구조(렉시컬 환경)에 키로 등록되고, 변수 할당이 일어나면 이 자료구조의 변수 식별자에 해당하는 값을 변경한다.
- 함수의 상위 스코프는 함수 정의가 실행될 때 정적으로 결정된다.

# 14장 - 전연 변수의 문제점
## SUMMARY
- 함수 내부에서 선언된 지역 변수는 함수가 호출되면 생성되고, 함수가 종료하면 소멸한다.
- 변수의 스코프는 좁을수록 좋다.

# 15장 - let, const 키워드와 블록 레벨 스코프
## SUMMARY
- var 키워드로 선언한 변수는 오로지 함수의 코드 블록만을 지역 스코프로 인정한다.
- let, const 키워드로 선언된 변수는 블록 레벨 스코프를 따른다.
- let 키워드로 선언한 변수는 스코프의 시작 지점부터 초기화 단계 시작 지점(변수 선언문)까지 변수를 참조할 수 없다. -> 일시적 사각지대(Temporal Dead Zone; TDZ)
