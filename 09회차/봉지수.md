# 33장 - 7번째 데이터 타입 Symbol
## SUMMARY
- 심벌은 ES6에서 도입된 7번째 데이터 타입으로 **변경 불가능한 원시 타입의 유일무이한 값**이다.
- Symbol.keyFor 메서드를 사용하면 전역 심벌 레지스트리에 저장된 심벌 값의 키를 추출할 수 있다.

```javascript
// 전역 심벌 레지스트리에 mySymbol이라는 키로 저장된 심벌 값이 없으면 새로운 심벌 값을 생성
const s1 = Symbol.for('mySymbol');
// 전역 심벌 레지스트리에 저장된 심벌 값의 키를 추출
Symbol.keyFor(s1); // -> mySymbol

// Symbol 함수를 호출하여 생성한 심벌 값은 전역 심벌 레지스트리에 등록되어 관리되지 않는다.
const s2 = Symbol('foo');
// 전역 심벌 레지스트리에 저장된 심벌 값의 키를 추출
Symbol.keyFor(s2); // -> undefined
```

- 자바스크립트가 제공하는 빌트인 심벌 값을 ECMAScript 사양에서는 **Well-known Symbol**이라 부른다.
- 언제, 왜 심벌을 사용하는가?
  - 중복되지 않는 상수 값 생성 시: 변경/중복될 가능성이 있는 무의미한 상수 대신 중복될 가능성이 없는 유일무이한 심벌 값을 사용할 수 있다.
  - 프로퍼티 은닉 시: 심벌 값을 프로퍼티 키로 사용하여 프로퍼티를 생성하면 외부에 노출할 필요가 없는 프로퍼티를 은닉할 수 있다.
  - 표준 빌트인 객체 확장 시: 중복될 가능성이 없는 심벌 값으로 프로퍼티 키를 생성하여 표준 빌트인 객체를 확장하면 표준 빌트인 객체의 기존 프로퍼티 키와 충돌하지 않는 것은 물론, 표준 사양의 버전이 올라감에 따라 추가될지 모르는 어떤 프로퍼티 키와도 충돌할 위험이 없어 안전하게 표준 빌트인 객체를 확장할 수 있다.

# 34장 - 이터러블
## SUMMARY
- ES6에서 도입된 이터레이션 프로토콜은 순회 가능한 데이터 컬렉션(자료구조)을 만들기 위해 ECMAScript 사양에 정의하여 미리 약속한 규칙이다.
- 이터레이션 프로토콜은 데이터 소비자(for...of, 스프레드 문법 등)와 데이터 공급자(Array, String 등)를 연결하는 인터페이스의 역할을 한다.
- ES6 이전의 순회 가능한 데이터 컬렉션, 즉 배열, 문자열, 유사 배열 객체, DOM 컬렉션, arguments 등은 통일된 규약 없이 각자 나름의 구조를 가지고 for 문, for...in 문, forEach 메서드 등 다양한 방법으로 순회할 수 있었다. -> ES6에서는 이터레이션 프로토콜을 준수하는 이터러블로 통일했다.
- 이터러블은 **Symbol.interator**를 프로퍼티 키로 사용한 메서드를 직접 구현하거나 프로토타입 체인을 통해 상속받은 객체를 말한다.
  - ex) 배열은 Array.prototype의 Symbol.iterator 메서드를 상속받는 이터러블이다.
  - 일반 객체는 이터러블 프로토콜을 준수한 이터러블이 아니다. -> for...of 문으로 순회할 수 없으며 스프레드 문법과 배열 디스트럭처링 할당의 대상으로 사용할 수 없다.

```javascript
const isIterable = v => v !== null && typeof v[Symbol.iterator] === 'function';

// 배열, 문자열, Map, Set 등은 이터러블이다.
isIterable([]); // -> true
isIterable(''); // -> true
isIterable(''); // -> true
isIterable(''); // -> true
isIterable({}); // -> false
```

- 이터러블 프로토콜을 준수하면 **이터러블**이다.
- 이터러블의 Symbol.iterator 메서드는 **이터레이터**를 반환한다.
- 이터레이터는 **next 메서드**를 갖는다.
- next 메서드를 호출하면 이터러블을 순차적으로 한 단계씩 순회하며 순회 결과를 나타내는 **이터레이터 리절트 객체**를 반환한다.
- 이터레이터 리절트 객체는 **value와 done 프로퍼티**를 갖는다.
- value 프로퍼티는 현재 순회 중인 이터러블의 값을 나타내며, done 프로퍼티는 이터러블의 순회 완료 여부를 나타낸다.

```javascript
// 배열은 이터러블 프로토콜을 준수한 이터러블이다.
const array = [1, 2, 3];

// Symbol.iterator 메서드는 이터레이터는 반환한다. 이터레이터는 next 메서드를 갖는다.
const iterator = array[Symbol.iterator]();

// next 메서드를 호출하면 이터러블을 순회하며 순회 결과를 나타내는 이터레이터 리절트 객체를 반환한다.
// 이터레이터 리절트 객체는 value와 done 프로퍼티를 갖는 객체다.
console.log(iterator.next()); // { value: 1, done: false }
console.log(iterator.next()); // { value: 2, done: false }
console.log(iterator.next()); // { value: 3, done: false }
console.log(iterator.next()); // { value: undefined, done: true }
```

# 35장 - 스프레드 문법
## SUMMARY
- ES6에서 도입된 스프레드 문법 ...은 하나로 뭉쳐 있는 여러 값들의 집합을 펼쳐서 개별적인 **값들의 목록**으로 만든다.

```javascript
console.log(...[1, 2, 3]); // 1 2 3
console.log(...'Hello'); // H e l l o
```

- 스프레드 문법의 결과는 값이 아니다. 스프레드 문법의 결과를 변수에 할당할 수 없다.
- 스프레드 문법의 결과물은 쉼표로 구분한 값의 목록을 사용하는 문맥에서만 사용할 수 있다.
  - 함수 호출문의 인수 목록
  - 배열 리터럴의 요소 목록
  - 객체 리터럴의 프로퍼티 목록
- Rest 파라미터와 스프레드 문법은 서로 반대의 개념이다.

```javascript
// Rest 파라미터는 인수들의 목록을 배열로 전달받는다.
function foo(...rest) {
  console.log(rest); // 1, 2, 3 -> [1, 2, 3]
}

// 스프레드 문법은 배열과 같은 이터러블을 펼쳐서 개별적인 값들의 목록을 만든다.
foo(...[1, 2, 3]); // [1, 2, 3] -> 1, 2, 3
```

- 이터러블이 아닌 유사 배열 객체는 스프레드 문법의 대상이 될 수 없다.
- 스프레드 문법을 사용하면 기존 ES5에서 사용하던 concat, splice, slice 등의 방법보다 더욱 간결하고 가독성 좋게 표현할 수 있다.
- 스프레드 프로퍼티 제안은 일반 객체를 대상으로도 스프레드 문법의 사용을 허용한다. 

